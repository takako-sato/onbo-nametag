<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>【研修用】一括画像名前入れツール</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --color-text: #565CAA;
      --color-bg: #ffffff;
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Noto Sans JP", sans-serif;
      max-width: 560px;
      margin: 0 auto;
      padding: 24px 16px;
      background: #f5f5f5;
      min-height: 100vh;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0 0 24px;
      color: #333;
    }
    .form-group {
      margin-bottom: 16px;
    }
    .form-group label {
      display: block;
      font-size: 0.875rem;
      font-weight: 700;
      margin-bottom: 4px;
      color: #333;
    }
    .form-group input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .form-group input[type="file"] {
      width: 100%;
      padding: 10px;
      font-size: 0.875rem;
      border: 1px dashed #999;
      border-radius: 8px;
      background: #fff;
    }
    button {
      width: 100%;
      padding: 14px;
      font-size: 1rem;
      font-weight: 700;
      font-family: inherit;
      color: #fff;
      background: var(--color-text);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 8px;
    }
    button:hover { opacity: 0.9; }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .note {
      font-size: 0.75rem;
      color: #666;
      margin-top: 24px;
      line-height: 1.5;
    }
    #log {
      margin-top: 16px;
      font-size: 0.875rem;
      color: #333;
    }
    #log.error { color: #c00; }
  </style>
</head>
<body>
  <h1>研修で画像に名前を入れるツール</h1>
  <p style="font-size:0.875rem;color:#666;margin:0 0 20px;">画像の中央下に「施策名 名前」を入れます。</p>

  <div class="form-group">
    <label for="campaign">施策名</label>
    <input type="text" id="campaign" placeholder="例: リリース研修_CP⑦" value="">
  </div>
  <div class="form-group">
    <label for="author">名前</label>
    <input type="text" id="author" placeholder="名前を入力" value="">
  </div>
  <div class="form-group">
    <label for="textColor">テキストの色</label>
    <div style="display:flex;align-items:center;gap:12px;">
      <input type="color" id="textColor" style="width:56px;height:40px;padding:2px;cursor:pointer;border:1px solid #ccc;border-radius:8px;">
      <span id="textColorHex" style="font-size:0.875rem;color:#666;"></span>
    </div>
  </div>
  <div class="form-group">
    <label for="fileOrFolder">フォルダ選択（フォルダ配下の全階層一括で可能）</label>
    <input type="file" id="fileOrFolder" webkitdirectory directory multiple accept="image/png,image/jpeg,image/jpg,image/webp,image/gif" style="display:block;padding:10px;font-size:0.875rem;">
    <p id="selectionStatus" style="font-size:0.875rem;color:#666;margin:8px 0 0;"></p>
  </div>
  <button type="button" id="run">名前を入れてダウンロード</button>

  <div id="log"></div>

  <p class="note">テキストは太字・白背景で描画されます（色は選択可能）。フォルダを選ぶと配下の全階層の画像を一括処理し、<strong>ファイル名・フォルダ階層をそのまま</strong>ZIPでまとめてダウンロードします。<br><br>何か要望や質問等は、Slackで@takako_satoまで。</p>

  <script>
    (function () {
      const BG_COLOR = '#ffffff';
      const MARGIN_RATIO = 0.04;
      const TEXT_RATIO = 0.045;
      const PADDING_RATIO = 0.015;

      function randomHexColor() {
        var r = Math.floor(Math.random() * 200);
        var g = Math.floor(Math.random() * 200);
        var b = Math.floor(Math.random() * 200);
        return '#' + [r, g, b].map(function (x) { return ('0' + x.toString(16)).slice(-2); }).join('');
      }

      function $(id) { return document.getElementById(id); }
      function log(msg, isError) {
        const el = $('log');
        el.textContent = msg;
        el.className = isError ? 'error' : '';
      }

      function drawCaption(img, campaign, author, textColor) {
        const c = document.createElement('canvas');
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const w = c.width, h = c.height;
        const short = Math.min(w, h);

        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0);

        const fontSize = Math.max(12, Math.floor(short * TEXT_RATIO));
        const padding = Math.max(4, Math.floor(short * PADDING_RATIO));
        const margin = Math.floor(short * MARGIN_RATIO);

        const text = [campaign, author].filter(Boolean).join(' ');
        ctx.font = `700 ${fontSize}px "Noto Sans JP", sans-serif`;

        const metrics = ctx.measureText(text);
        const tw = metrics.width;
        let th = 0;
        if (typeof metrics.actualBoundingBoxAscent === 'number' && typeof metrics.actualBoundingBoxDescent === 'number') {
          th = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        }
        if (th <= 0) th = fontSize * 1.2;

        const x = (w - tw) / 2;
        const y = h - th - margin - padding;

        const x1 = x - padding;
        const y1 = y - padding;
        const x2 = x + tw + padding;
        const y2 = y + th + padding;
        const r = Math.max(2, padding / 2);

        ctx.fillStyle = BG_COLOR;
        roundRect(ctx, x1, y1, x2 - x1, y2 - y1, r);
        ctx.fill();

        ctx.fillStyle = textColor || $('textColor').value;
        const textBaselineY = (typeof metrics.actualBoundingBoxAscent === 'number') ? (y + metrics.actualBoundingBoxAscent) : (y + fontSize * 0.85);
        ctx.fillText(text, x, textBaselineY);

        return c;
      }

      function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }

      const IMAGE_EXTS = /\.(png|jpe?g|gif|webp|bmp)$/i;
      function isImageFile(file) {
        return IMAGE_EXTS.test(file.name);
      }

      /** ZIP内のパス（階層を保持）。フォルダ選択時は webkitRelativePath、そうでなければファイル名のみ */
      function getZipPath(file) {
        return file.webkitRelativePath || file.name;
      }

      function collectFiles() {
        return Array.from($('fileOrFolder').files).filter(isImageFile);
      }

      function updateSelectionStatus() {
        const files = collectFiles();
        const el = $('selectionStatus');
        if (files.length === 0) el.textContent = '';
        else el.textContent = '選択済み: ' + files.length + ' 件';
      }

      $('fileOrFolder').addEventListener('change', updateSelectionStatus);

      $('run').addEventListener('click', function () {
        const campaign = ($('campaign').value || '').trim();
        const author = ($('author').value || '').trim();
        const textColor = $('textColor').value;
        const files = collectFiles();

        if (!files.length) {
          log('フォルダを選択してください。', true);
          return;
        }

        const btn = $('run');
        btn.disabled = true;
        log('処理中...（' + files.length + ' 件）');

        const total = files.length;
        const zip = new JSZip();
        var rel = files[0].webkitRelativePath || '';
        var zipName = rel ? (rel.split('/')[0] || rel.split('\\')[0] || 'captioned') + '.zip' : 'captioned.zip';

        function process(i) {
          if (i >= total) {
            zip.generateAsync({ type: 'blob' }).then(function (blob) {
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = zipName;
              a.click();
              URL.revokeObjectURL(a.href);
              log(total + ' 件を ' + zipName + ' でダウンロードしました。');
              btn.disabled = false;
            }).catch(function () {
              log('ZIPの作成に失敗しました。', true);
              btn.disabled = false;
            });
            return;
          }
          const file = files[i];
          const reader = new FileReader();
          reader.onload = function () {
            const img = new Image();
            img.onload = function () {
              const canvas = drawCaption(img, campaign, author, textColor);
              const pathInZip = getZipPath(file);
              const mime = file.name.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
              canvas.toBlob(function (blob) {
                zip.file(pathInZip, blob);
                process(i + 1);
              }, mime, 0.95);
            };
            img.onerror = function () {
              log('画像の読み込みに失敗しました: ' + (file.webkitRelativePath || file.name), true);
              btn.disabled = false;
            };
            img.src = reader.result;
          };
          reader.readAsDataURL(file);
        }

        process(0);
      });

      (function initTextColor() {
        var color = randomHexColor();
        $('textColor').value = color;
        $('textColorHex').textContent = color;
      })();

      $('textColor').addEventListener('input', function () {
        $('textColorHex').textContent = this.value;
      });
    })();
  </script>
</body>
</html>
